//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : VisualizacaoMapa.cpp
//  @ Date : 06/09/2011
//  @ Author :
//
//


#include "VisualizacaoMapa.h"
#include "MapaMDE.h"
#include "math.h"
#include "fstream"
#include <QDate>
#include<janelaprincipal.h>




/*!
  \class VisualizacaoMapa



     \previouspage PainelVisualizacaoOpenGL



     \nextpage All Classes


     \startpage All Classes


  \brief Class to represent a visualization of all contents in the process of creating a reservoir

  */


/*!
  \variable VisualizacaoMapa::mapa
  \brief a pointer to MapaMDE object.

*/

/*!
  \variable VisualizacaoMapa::fluxo
  \brief a pointer to Fluxo object.

*/

/*!
  \variable VisualizacaoMapa::inundacao
  \brief a pointer to Inundacao object.

*/

/*!
  \variable VisualizacaoMapa::listaDeCamadas
  \brief a list of Camada to hold the Camadas create by user

*/

/*!
  \variable VisualizacaoMapa::camadasSomadas
  \brief a pointer to pointer, representing a matrix of sum of Camadas to help in position algorithm

*/

/*!
  \variable VisualizacaoMapa::vetorDeZooms
  \brief a pointer to pointer, representig a matrix with the value of zooms possible in this MDE

*/

/*!
  \variable VisualizacaoMapa::marcaInicioX
  \brief the start position in axis-x of the drainage network's stretch

*/




/*!
  \variable VisualizacaoMapa::marcaFinalX
  \brief the end position in axis-x of the drainage network's stretch

*/

/*!
  \variable VisualizacaoMapa::marcaInicioY
  \brief the start position in axis-y of the drainage network's stretch

*/




/*!
  \variable VisualizacaoMapa::marcaFinalY
  \brief the end position in axis-y of the drainage network's stretch

*/


/*!
  \variable VisualizacaoMapa::marcouInicio
  \brief the flag to hold if user has marked the start position of drainage network's stretch

*/

/*!
  \variable VisualizacaoMapa::marcouFim
  \brief the flag to hold if user has marked the end position of drainage network's stretch

*/

/*!
  \variable VisualizacaoMapa::proporcaoZoom
  \brief an internal variable for the proportion of the zoom. It's used to definy the point size

*/


/*!
  \variable VisualizacaoMapa::constanteDeProporcaoZoom
  \brief the value for a constant variable used in proporcaoZoom

*/

/*!
  \variable VisualizacaoMapa::tamanhoDaBarraDeZoom
  \brief the size of zoom bar

*/

/*!
  \variable VisualizacaoMapa::maxPointSize
  \brief the maximum point's size

*/

/*!
  \variable VisualizacaoMapa::estaPreSalvo
  \brief the flag to control if this visualization is saved in Area de Projeto

*/


/*!
  \variable VisualizacaoMapa::pesoEBarragem
  \brief the value of the weight for dam's extent. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoHBarragem
  \brief the value of the weight for dam's high. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoAreaAlagada
  \brief the value of the weight for flooded area. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoVolume
  \brief the value of the weight for reservoir's volume. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoABarragem
  \brief the value of the weight for dam's area. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoCamadas
  \brief the value of the sum of cell's in camadasSomadas that are in the resorvoir. Used in position algorithm

*/




/*!
  \variable VisualizacaoMapa::pesoEBarragemPadrao
  \brief the default value of the weight for dam's extent. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoHBarragemPadrao
  \brief the default value of the weight for dam's high. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoAreaAlagadaPadrao
  \brief the default value of the weight for flooded area. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoVolumePadrao
  \brief the default value of the weight for reservoir's volume. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoABarragemPadrao
  \brief the default value of the weight for dam's area. Used in position algorithm

*/

/*!
  \variable VisualizacaoMapa::pesoCamadasPadrao
  \brief the default value of the sum of cell's in camadasSomadas that are in the resorvoir. Used in position algorithm

*/



/*!
  \variable VisualizacaoMapa::maxPontosABuscar
  \brief the maximun iteration for recursive functions

*/





/*!
  \fn VisualizacaoMapa::VisualizacaoMapa()
  Default Constructor. Creates a object with its pointers set to null



*/


VisualizacaoMapa::VisualizacaoMapa(){

    mapa = NULL;
    fluxo = NULL;
    inundacao = NULL;
    vetorDeZooms = NULL;



}




/*!
  \fn VisualizacaoMapa::VisualizacaoMapa(const char *caminhoMapa, int largura, int altura)
  Constructor. Creates a object VisualizacaoMapa for the path caminhoMapa



*/
VisualizacaoMapa::VisualizacaoMapa(const char *caminhoMapa, int largura, int altura) {

    mapa = new MapaMDE(caminhoMapa);


    fluxo = new Fluxo(mapa->getNLinhas(),mapa->getNColunas());
    inundacao = new Inundacao(mapa->getNLinhas(),mapa->getNColunas());

    //setando as variaveis para valores padroes
    zoom = 0;

    //variaveis constantes de proporcoes
    constanteDeProporcaoZoom = 0.1;
    proporcaoTela = 1;
    proporcaoX = mapa->getNColunas()*proporcaoTela;
    proporcaoY = mapa->getNLinhas()*proporcaoTela;


    larguraTela = largura;
    alturaTela = altura;

    //===Define proporção de zoom e tamanho do ponto inicialmente===
    proporcaoZoom = zoom*constanteDeProporcaoZoom +1;
    float fatorDeCorrecao = 1;
    tamanhoDoPonto =  (larguraTela/proporcaoX) > (alturaTela/proporcaoY)?(larguraTela/proporcaoX):(alturaTela/proporcaoY) ;
    tamanhoDoPonto += fatorDeCorrecao;



    maxPointSize = 63;
    double maiorProporcao = 1.0*alturaTela/proporcaoY > 1.0*larguraTela/proporcaoX ? (double)alturaTela*1.0/proporcaoY : (double)larguraTela*1.0/proporcaoX;
    //===Define aqui o tamanho da barra de zoom em função do maior valor possivel para o ponto===
    tamanhoDaBarraDeZoom = (maxPointSize/(maiorProporcao) - 1.0)/constanteDeProporcaoZoom;


    tamanhoDaBarraDeZoom = maxPointSize>tamanhoDaBarraDeZoom?tamanhoDaBarraDeZoom:maxPointSize-1;
    //===Define o tamanho do vetor de zooms em função do tamanho da barra===
    tamanhoDaBarraDeZoom = 25;
    vetorDeZooms = new double *[2];
    for(int i = 0;i < 2; i++)
        vetorDeZooms[i] = new double[tamanhoDaBarraDeZoom+1];


    //===Inicializa o valor de cada zoom===
    for(int i=0; i<=tamanhoDaBarraDeZoom ; i++)
    {

        vetorDeZooms[0][i] = larguraTela*(i*0.1+1);
        vetorDeZooms[1][i] = alturaTela*(i*0.1+1);
    }

    listaDeCamadas = new QList<Camada>();

    estaPreSalvo = false;

    //sera definido que se buscara em
    maxPontosABuscar = this->fluxo->qtdeCelulasRio;



    pesoEBarragem = pesoEBarragemPadrao;
    pesoHBarragem = pesoHBarragemPadrao;
    pesoAreaAlagada = pesoAreaAlagadaPadrao;
    pesoVolume = pesoVolumePadrao;
    pesoABarragem = pesoABarragemPadrao;

    pesoCamadas = pesoCamadasPadrao;





    camadasSomadas = new short int*[mapa->getNLinhas()];
    for(int i=0; i<mapa->getNLinhas(); ++i)
    {
        camadasSomadas[i] = new short int[mapa->getNColunas()];
        for(int j=0; j<mapa->getNLinhas() ; ++j)
            camadasSomadas[i][j] = 0;
    }



}


/*!
  \overload VisualizacaoMapa::operator=(QList<Camada> const& listaCamada)
  Operator to set listaCamada to variable listaDeCamadas

*/
QList<Camada> &VisualizacaoMapa::operator=(QList<Camada> const& listaCamada){

    if(listaDeCamadas == &listaCamada) return *listaDeCamadas;
    for( int it = 0 ; it< listaCamada.size();it++)
        listaDeCamadas->insert(it, listaCamada.at(it));

    return *listaDeCamadas;

}


/*!
  \fn VisualizacaoMapa::insereCamada(Camada c)
 Function to insert Camada c in listaDeCamadas

*/

void VisualizacaoMapa::insereCamada(Camada c){


    listaDeCamadas->push_back(c);
}

/*!
  \fn VisualizacaoMapa::getIndCamada(QString nome)
 Function to return the index of Camada named as nome in listaDeCamadas

*/

int VisualizacaoMapa::getIndCamada(QString nome){

    for(int i = 0; i< listaDeCamadas->size();i++){
        Camada c = listaDeCamadas->at(i);
        if( c.getNome() == nome)
            return i;
    }

    return -1;


}


/*!
  \overload VisualizacaoMapa::operator=(VisualizacaoMapa const& viMapa)
 Overloaded operator to assign the object viMapa to the current object(this)

*/
VisualizacaoMapa & VisualizacaoMapa::operator=(VisualizacaoMapa const& viMapa){


    mapa = new MapaMDE(*viMapa.mapa);
    fluxo = new Fluxo(*viMapa.fluxo);
    inundacao = new Inundacao(*viMapa.inundacao);


    //setando as variaveis para valores padroes
    zoom = viMapa.zoom;

    //variaveis constantes de proporcoes
    constanteDeProporcaoZoom = viMapa.constanteDeProporcaoZoom;
    proporcaoTela = viMapa.proporcaoTela;
    proporcaoX = viMapa.proporcaoX;
    proporcaoY = viMapa.proporcaoY;

    larguraTela = viMapa.larguraTela;
    alturaTela = viMapa.alturaTela;

    //===Define proporção de zoom e tamanho do ponto inicialmente===
    proporcaoZoom = viMapa.proporcaoZoom;

    tamanhoDoPonto =  viMapa.tamanhoDoPonto;


    maxPointSize = viMapa.maxPointSize;
    //===Define aqui o tamanho da barra de zoom em função do maior valor possivel para o ponto===
    tamanhoDaBarraDeZoom = viMapa.tamanhoDaBarraDeZoom;

    //===Define o tamanho do vetor de zooms em função do tamanho da barra===
    vetorDeZooms = new double *[2];
    for(int i = 0;i < 2; i++)
        vetorDeZooms[i] = new double[tamanhoDaBarraDeZoom+1];


    //===Inicializa o valor de cada zoom===
    for(int i=0; i<=tamanhoDaBarraDeZoom ; i++)
    {

        vetorDeZooms[0][i] = viMapa.vetorDeZooms[0][i];
        vetorDeZooms[1][i] =  viMapa.vetorDeZooms[1][i];
    }

    estaPreSalvo = viMapa.estaPreSalvo;

    listaDeCamadas = new QList<Camada>();
    for(int i = 0; i< viMapa.listaDeCamadas->size();i++)
        listaDeCamadas->insert(i,viMapa.listaDeCamadas->at(i));



    maxPontosABuscar = viMapa.maxPontosABuscar;


    pesoEBarragem = viMapa.pesoEBarragem;
    pesoHBarragem = viMapa.pesoHBarragem;
    pesoAreaAlagada = viMapa.pesoAreaAlagada;
    pesoVolume = viMapa.pesoVolume;
    pesoABarragem =viMapa.pesoABarragem;

    pesoCamadas =viMapa.pesoCamadas;


    camadasSomadas = new short int*[mapa->getNLinhas()];
    for(int i=0; i<mapa->getNLinhas(); ++i)
    {
        camadasSomadas[i] = new short int[mapa->getNColunas()];
        for(int j=0; j<mapa->getNLinhas() ; ++j)
            camadasSomadas[i][j] = viMapa.camadasSomadas[i][j];

    }


    return *this;

}


/*!
  \fn VisualizacaoMapa::VisualizacaoMapa(VisualizacaoMapa const &viMapa)
Copy Constructor. Creates an object receiving attributes from viMapa

*/
VisualizacaoMapa::VisualizacaoMapa(VisualizacaoMapa const &viMapa){


    mapa = new MapaMDE(*viMapa.mapa);
    fluxo = new Fluxo(*viMapa.fluxo);
    inundacao = new Inundacao(*viMapa.inundacao);


    //setando as variaveis para valores padroes
    zoom = 0;

    //variaveis constantes de proporcoes
    constanteDeProporcaoZoom = viMapa.constanteDeProporcaoZoom;
    proporcaoTela = viMapa.proporcaoTela;
    proporcaoX = viMapa.proporcaoX;
    proporcaoY = viMapa.proporcaoY;


    larguraTela = viMapa.larguraTela;
    alturaTela = viMapa.alturaTela;

    //===Define proporção de zoom e tamanho do ponto inicialmente===
    proporcaoZoom = viMapa.proporcaoZoom;

    tamanhoDoPonto =  viMapa.tamanhoDoPonto;


    maxPointSize = viMapa.maxPointSize;
    //===Define aqui o tamanho da barra de zoom em função do maior valor possivel para o ponto===
    tamanhoDaBarraDeZoom = viMapa.tamanhoDaBarraDeZoom;

    //===Define o tamanho do vetor de zooms em função do tamanho da barra===
    vetorDeZooms = new double *[2];
    for(int i = 0;i < 2; i++)
        vetorDeZooms[i] = new double[tamanhoDaBarraDeZoom+1];


    //===Inicializa o valor de cada zoom===
    for(int i=0; i<=tamanhoDaBarraDeZoom ; i++)
    {

        vetorDeZooms[0][i] = viMapa.vetorDeZooms[0][i];
        vetorDeZooms[1][i] =  viMapa.vetorDeZooms[1][i];
    }

    estaPreSalvo = viMapa.estaPreSalvo;

    listaDeCamadas = new QList<Camada>();
    for(int i = 0; i< viMapa.listaDeCamadas->size();i++)
        listaDeCamadas->insert(i,viMapa.listaDeCamadas->at(i));

    maxPontosABuscar = viMapa.maxPontosABuscar;


    pesoEBarragem = viMapa.pesoEBarragem;
    pesoHBarragem = viMapa.pesoHBarragem;
    pesoAreaAlagada = viMapa.pesoAreaAlagada;
    pesoVolume = viMapa.pesoVolume;
    pesoABarragem =viMapa.pesoABarragem;


    pesoCamadas =viMapa.pesoCamadas;


    camadasSomadas = new short int*[mapa->getNLinhas()];
    for(int i=0; i<mapa->getNLinhas(); ++i)
    {
        camadasSomadas[i] = new short int[mapa->getNColunas()];
        for(int j=0; j<mapa->getNLinhas() ; ++j)
            camadasSomadas[i][j] = viMapa.camadasSomadas[i][j];
    }


}


/*!
  \fn VisualizacaoMapa::getMapa()
Returns mapa

*/
MapaMDE *VisualizacaoMapa::getMapa() {

    return mapa;

}


/*!
  \fn VisualizacaoMapa::getZoom()
Returns zoom

*/
int VisualizacaoMapa::getZoom() {
    return zoom;
}



/*!
  \fn VisualizacaoMapa::setZoom(int zoom)
Function to set the zoom value

*/


void VisualizacaoMapa::setZoom(int zoom) {
    //aqui mexeremos nas variaveis quando ocorrer o zoom
    this->zoom = zoom;

    proporcaoZoom = zoom*constanteDeProporcaoZoom +1;

    setTamanhoPonto(larguraTela,alturaTela);



}


/*!
  \fn VisualizacaoMapa::setTamanhoPonto(int larguraTela, int alturaTela)
Function to calculate and set the point size

*/
void VisualizacaoMapa::setTamanhoPonto(int larguraTela, int alturaTela){
    float fatorDeCorrecao = 1;

    tamanhoDoPonto = (larguraTela/proporcaoX) > (alturaTela/proporcaoY)?(larguraTela*proporcaoZoom/proporcaoX):(alturaTela*proporcaoZoom/proporcaoY) ;

    tamanhoDoPonto = tamanhoDoPonto + fatorDeCorrecao;
    this->alturaTela = alturaTela;
    this->larguraTela = larguraTela;

}



/*!
  \fn VisualizacaoMapa::encontraPontosJusante(int x, int y,bool& encontrado, bool** matrizVisitados, int &pontosBuscados)
Function to look for points(and creates the list of candidates to position the dam) until the end point of stretch drainage network is founded.

*/
void VisualizacaoMapa::encontraPontosJusante(int x, int y,bool& encontrado, bool** matrizVisitados, int &pontosBuscados){


    if(pontosBuscados > this->fluxo->qtdeCelulasRio)
        throw pontosBuscados;




    if(x == marcaFinalX && y == marcaFinalY){ //Se encontrou ponto marcado como final, termina
        encontrado = true;
        return;
    }

    //Visita vizinhos em sentindo horário
    //A partir do vizinho superior esquerdo (x-1,y-1)




    //Vizinho (x-1,y-1)
    if(x-1>=0 && y-1>=0 && x-1<this->getMapa()->getNColunas() && y-1<this->getMapa()->getNLinhas())
        if(fluxo->rio[y-1][x-1] && !matrizVisitados[y-1][x-1]){
            matrizVisitados[y-1][x-1] = true;
            pontosBuscados++;

            encontraPontosJusante(x-1,y-1,encontrado,matrizVisitados,pontosBuscados);

            if(encontrado)
                return;
            //Marca ponto como não pertencente ao caminho
            matrizVisitados[y-1][x-1] = false;

        }



    //Vizinho (x,y-1)
    if(x>=0 && y-1>=0 && x<getMapa()->getNColunas() && y-1<getMapa()->getNLinhas())
        if(fluxo->rio[y-1][x] && !matrizVisitados[y-1][x]){
            matrizVisitados[y-1][x] = true;
            pontosBuscados++;
            encontraPontosJusante(x,y-1,encontrado,matrizVisitados,pontosBuscados);

            if(encontrado)
                return;
            //Marca ponto como não pertencente ao caminho
            matrizVisitados[y-1][x] = false;

        }

    //Vizinho (x+1,y-1)
    if(x+1>=0 && y-1>=0 && x+1<getMapa()->getNColunas() && y-1<getMapa()->getNLinhas())
        if(fluxo->rio[y-1][x+1] && !matrizVisitados[y-1][x+1]){
            matrizVisitados[y-1][x+1] = true;
            pontosBuscados++;
            encontraPontosJusante(x+1,y-1,encontrado,matrizVisitados,pontosBuscados);

            if(encontrado)
                return;
            //Marca ponto como não pertencente ao caminho
            matrizVisitados[y-1][x+1] = false;

        }

    //Vizinho (x+1,y)
    if(x+1>=0 && y>=0 && x+1<getMapa()->getNColunas() && y<getMapa()->getNLinhas())
        if(fluxo->rio[y][x+1] && !matrizVisitados[y][x+1]){
            matrizVisitados[y][x+1] = true;
            pontosBuscados++;
            encontraPontosJusante(x+1,y,encontrado,matrizVisitados,pontosBuscados);

            if(encontrado)
                return;
            //Marca ponto como não pertencente ao caminho
            matrizVisitados[y][x+1] = false;

        }

    //Vizinho (x+1,y+1)
    if(x+1>=0 && y+1>=0 && x+1<getMapa()->getNColunas() && y+1<getMapa()->getNLinhas())
        if(fluxo->rio[y+1][x+1] && !matrizVisitados[y+1][x+1]){
            matrizVisitados[y+1][x+1] = true;
            pontosBuscados++;
            encontraPontosJusante(x+1,y+1,encontrado,matrizVisitados,pontosBuscados);

            if(encontrado)
                return;
            //Marca ponto como não pertencente ao caminho
            matrizVisitados[y+1][x+1] = false;

        }

    //Vizinho (x,y+1)
    if(x>=0 && y+1>=0 && x<getMapa()->getNColunas() && y+1<getMapa()->getNLinhas())
        if(fluxo->rio[y+1][x]&& !matrizVisitados[y+1][x]){
            matrizVisitados[y+1][x] = true;
            pontosBuscados++;
            encontraPontosJusante(x,y+1,encontrado,matrizVisitados,pontosBuscados);

            if(encontrado)
                return;
            //Marca ponto como não pertencente ao caminho
            matrizVisitados[y+1][x] = false;

        }

    //Vizinho (x-1,y+1)
    if(x-1>=0 && y+1>=0 && x-1<getMapa()->getNColunas() && y+1<getMapa()->getNLinhas())
        if(fluxo->rio[y+1][x-1]&& !matrizVisitados[y+1][x-1]){
            matrizVisitados[y+1][x-1] = true;
            pontosBuscados++;
            encontraPontosJusante(x-1,y+1,encontrado,matrizVisitados,pontosBuscados);

            if(encontrado)
                return;
            //Marca ponto como não pertencente ao caminho
            matrizVisitados[y+1][x-1] = false;

        }

    //Vizinho (x-1,y)
    if(x-1>=0 && y>=0 && x-1<getMapa()->getNColunas() && y<getMapa()->getNLinhas())
        if(fluxo->rio[y][x-1] && !matrizVisitados[y][x-1]){
            matrizVisitados[y][x-1] = true;
            pontosBuscados++;
            encontraPontosJusante(x-1,y,encontrado,matrizVisitados,pontosBuscados);

            if(encontrado)
                return;
            //Marca ponto como não pertencente ao caminho
            matrizVisitados[y][x-1] = false;

        }
}


/*!
  \fn VisualizacaoMapa::atualizaCamadasSomadas()
Function to sum all Camadas in listaDeCamadas, cell by cell. The answer is seted in th matrix camadasSomadas

*/
void VisualizacaoMapa::atualizaCamadasSomadas(){


    if(listaDeCamadas->isEmpty()) return;
    for(int i=0; i<mapa->getNLinhas(); ++i){
        for(int j=0; j<mapa->getNLinhas() ; ++j){
            for(int k = 0; k< listaDeCamadas->size();k++){
                if(!listaDeCamadas->at(k).estaVisivel) continue;
                if(listaDeCamadas->at(k).pontos[i][j]){
                    Camada aux = listaDeCamadas->at(k);
                    camadasSomadas[i][j] += (aux).getPeso();
                }
            }
        }

    }

}


/*!
  \fn VisualizacaoMapa::getFuncaoObjetivo()
Function to return the value of objective function with the weights.

*/
int VisualizacaoMapa::getFuncaoObjetivo(){


    int resp  ;

    atualizaPesoCamadas();
    resp = pesoEBarragem*inundacao->comprimentoBarragemTocada + pesoHBarragem*inundacao->nivelAgua +
            pesoAreaAlagada*inundacao->areaLaminaAgua + pesoVolume*inundacao->volumeAgua +
            pesoABarragem*inundacao->areaBarragemTocada + pesoCamadas;



    return resp;


}


/*!
  \fn VisualizacaoMapa::~VisualizacaoMapa()
Destructor.

*/
VisualizacaoMapa::~VisualizacaoMapa(){

try{

//CUIDADO
    if(camadasSomadas != NULL){
        for(int i=0;i< mapa->getNLinhas() ;i++)
            delete []this->camadasSomadas[i];

        delete []this->camadasSomadas;
        this->camadasSomadas = NULL;
    }


    cout<<"Tentando deletar visualizaçao";
    if(mapa != NULL){
        delete this->mapa;
        this->mapa = NULL;
    }


    if(fluxo != NULL){
        delete this->fluxo;
        this->fluxo = NULL;

    }
    if(inundacao != NULL){

        delete this->inundacao;
        this->inundacao = NULL;

    }

    if(vetorDeZooms != NULL){
        for(int i=0;i< 2;i++)
            delete []this->vetorDeZooms[i];

        delete []this->vetorDeZooms;
        this->vetorDeZooms = NULL;
    }

    if(listaDeCamadas != NULL){
        delete listaDeCamadas;
        listaDeCamadas = NULL;
    }
    }catch(exception e){

        QString erroMsg="Erro no destrutor da classe VisualizacaoMapa";
        ofstream erro(JanelaPrincipal::urllog.toStdString().data());


        erro<<"Erro ocorrido em: ";
        erro<< QDate::currentDate().toString("dd.MM.yyyy").toStdString();
        erro<<endl;
        erro<<erroMsg.toStdString()<<endl;
        erro<<e.what()<<endl;
        erro.close();


    }




}


/*!
  \fn VisualizacaoMapa::getProporcaoZoom()
Function to return the proportion of the zoom

*/

double VisualizacaoMapa::getProporcaoZoom(){
    return proporcaoZoom;
}


/*!
  \fn VisualizacaoMapa::getProporcaoX()
Function to return the proportion in axis-x for the opengl painel

*/
int VisualizacaoMapa::getProporcaoX(){
    return proporcaoX;
}

/*!
  \fn VisualizacaoMapa::getProporcaoY()
Function to return the proportion in axis-y for the opengl painel

*/
int VisualizacaoMapa::getProporcaoY(){
    return proporcaoY;
}


/*!
  \fn VisualizacaoMapa::getTamanhoDoPonto()
Function to return the size of the point
*/

int VisualizacaoMapa::getTamanhoDoPonto(){
    return tamanhoDoPonto;
}

/*!
  \fn VisualizacaoMapa::atualizaPesos(int aa,int ab,int c,int eb,int hb)
Function to update the value of the weights
*/

void VisualizacaoMapa::atualizaPesos(int aa,int ab,int c,int eb,int hb){

    pesoAreaAlagada = aa;
    pesoABarragem = ab;
    pesoVolume = c;
    pesoEBarragem = eb;
    pesoHBarragem = hb;


}


/*!
  \fn VisualizacaoMapa::atualizaPesoCamadas()
Function to update the value of the Camada`s weight. Calculate price of all flooded cell.
*/

void VisualizacaoMapa::atualizaPesoCamadas(){

    pesoCamadas = 0;
    /*
#define BARRAGEM 2;
#define AFLUENTE 1;
#define ACIMA_BARRAGEM 3;
#define AGUA_BORDA_BARRAGEM 4;
#define AGUA 5;
*/

    if(listaDeCamadas->isEmpty())return;
    for(int i=0; i<mapa->getNLinhas(); ++i){
        for(int j=0; j<mapa->getNLinhas() ; ++j){
            if(camadasSomadas[i][j]!=0){
                if(inundacao->matrizEstados[i][j] == 5 || inundacao->matrizEstados[i][j]==2)
                        pesoCamadas += camadasSomadas[i][j];


            }

        }
    }






}

/*!
  \fn VisualizacaoMapa::setInundacao(int posX, int posY,int op,int val,int valEp)
Function to create a reservoir.
*/

void VisualizacaoMapa::setInundacao(int posX, int posY,int op,int val,int valEp){

    inundacao->inunda(posX,posY,fluxo->direcao,mapa->matrizDeElevacoes,fluxo->rio,op,val,valEp);

}
