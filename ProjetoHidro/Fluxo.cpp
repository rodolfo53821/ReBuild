//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : Fluxo.cpp
//  @ Date : 19/09/2011
//  @ Author : 
//
//




#include "Fluxo.h"
#include<QString>
#include<janelaprincipal.h>
#include <QTime>



/*!
  \class Fluxo

     \previouspage Camada

     \contentspage

     \nextpage Inundacao

     \startpage All Classes



  \brief Class for create the drainage network, calculated by the flow directionand flow accumulation


  */


/*!
    \variable Fluxo::direcao
    \brief the pointer to pointer, representing the matrix of flow direction


  */
/*!
    \variable Fluxo::fluxo
    \brief the pointer to pointer, representing the matrix of flow accumulation


  */

/*!
  \variable Fluxo::rio
  \brief the pointer to pointer, representing the matrix river`s cells (drainage network)


*/

/*!
  \variable Fluxo::fluxoMinimo
  \brief the minimum flow to consider a cell in the drainage network. Cell`s value in rio matrix above fluxoMinimo is considering a cell of network drainage


*/

/*!
  \variable Fluxo::valorPadraoFluxo
  \brief the default value for fluxoMinimo


*/
/*!
  \variable Fluxo::nLinhas
  \brief the numbers of lines of MDE


*/
/*!
  \variable Fluxo::nColunas
  \brief the number of columns of MDE


*/
/*!
  \variable Fluxo::qtdeCelulasRio
  \brief the number of cells that are in drainage network


*/
/*!
  \variable Fluxo::limiteAltidude

  number representing the maximum value of MDE cell`s elevation. Constant variable with value as 32768

*/

/*!
  \variable Fluxo::processado
  \brief the representing that a cell have been processed. Constant variable with value as 255

*/

/*!
  \typedef Fluxo::ponto
  \brief the object to map a cell(point) of MDE easily.

*/

/*!
  \variable Fluxo::vetorDeFilasDeNiveis
  \brief the queue of ponto used to restore the nexts ponto that will be  alagado

*/

/*!
  \variable Fluxo::direcaoDeFluxo
  \brief the matrix with predefined directions to help discovery the flow direction of a cell.
  Is used the maped numbers below for cell and its neighbor
      1      2      4
     128   cell     8
      64    32      16


*/

/*!
  \variable Fluxo::dirEsquerdaCima
  \brief the constant value of left/up direction. Constant variable with value as 1


*/

/*!
  \variable Fluxo::dirCima
  \brief the constant value of up direction. Constant variable with value as 2

*/

/*!
  \variable const static int Fluxo::dirDireitaCima
   constant value of right/up direction. Constant variable with value as 4

*/

/*!
  \variable Fluxo::dirDireita
  \brief the constant value of right direction. Constant variable with value as 8

*/

/*!
  \variable Fluxo::dirDireitaBaixo
  \brief the constant value of right/down direction. Constant variable with value as 16

*/
/*!
  \variable Fluxo::dirBaixo
  \brief the constant value of down direction. Constant variable with value as 32

*/

/*!
  \variable Fluxo::dirEsquerdaBaixo
  \brief the constant value of left/down direction. Constant variable with value as 64

*/
/*!
  \variable Fluxo::dirEsquerda
  \brief the constant value of left direction. Constant variable with value as 128

*/



/*!
    \fn Fluxo::calculaFluxo(short int** elevacoes,int noData)
    \brief function to calculated the drainage network.

    elevecoes is the matrix with cell`s elevation of terrain.
    noData is the value representing a invalid cell

    This function use three another private function:
    setInundacao to identify the flow direction of  each cell.
    setFluxo to identify the flow accumalate of each cell.
    setRio to identify cells that are in drainage network.

  */


void Fluxo::calculaFluxo(short int** elevacoes,int noData) {


    try {
        setInundacao(elevacoes);
    } catch (exception e) {
        QString erroMsg="Erro no método setInundacao da classe Fluxo";
        ofstream erro(JanelaPrincipal::urllog.toStdString().data());
        erro<<"Erro ocorrido em: ";
        erro<< QDate::currentDate().toString("dd.MM.yyyy").toStdString();
        erro<<endl;
        erro<<erroMsg.toStdString()<<endl;
        erro<<e.what()<<endl;
        erro.close();
    }
    try {
        setFluxo(elevacoes);
    } catch (exception e) {
        QString erroMsg="Erro no método setFluxo da classe Fluxo";

        ofstream erro(JanelaPrincipal::urllog.toStdString().data());

        erro<<"Erro ocorrido em: ";
        erro<< QDate::currentDate().toString("dd.MM.yyyy").toStdString();
        erro<<endl;
        erro<<erroMsg.toStdString()<<endl;
        erro<<e.what()<<endl;
        erro.close();
    }
    try {
        setRio(elevacoes,noData);
    } catch (exception e) {
        QString erroMsg="Erro no método da setRio classe Fluxo";
        ofstream erro(JanelaPrincipal::urllog.toStdString().data());


        erro<<"Erro ocorrido em: ";
        erro<< QDate::currentDate().toString("dd.MM.yyyy").toStdString();
        erro<<endl;
        erro<<erroMsg.toStdString()<<endl;
        erro<<e.what()<<endl;
        erro.close();
    }





    /*
    ofstream saida("saidaDir.txt");




    for(int i = 0; i < nLinhas; i++){
        for(int j = 0; j< nColunas; j++){
            switch(direcao[i][j]){
            case 1:
                saida<<"ce ";

                break;
            case 2:
                saida<<" c ";
                break;

            case 4:
                saida<<"cd ";
                break;
            case 8:
                saida<<" d ";
                break;
            case 16:
                saida<<"bd ";
                break;
            case 32:
                saida<<" b ";
                break;

            case 64:
                saida<<"be";
                break;
            case 128:
                saida<<" e ";
                break;



            }


            //saidaDir<<direcao[i][j]<<" ";
        }
    saida<<endl;
    }

    saida.close();


    ofstream saidaFluxoAcumulado("saidaFluxo.txt");

    for(int i = 0;i<nLinhas;i++){
        for(int j= 0; j<nColunas;j++)
            saidaFluxoAcumulado<<fluxo[i][j]<<";";
        saidaFluxoAcumulado<<endl;
    }
    saidaFluxoAcumulado.close();
*/

}

const int Fluxo::direcaoDeFluxo[129][2]={
    {0,0},{-1,-1},{-1,0},{0,0},{-1,1},{0,0},{0,0},{0,0},{0,1},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
    {1,1},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
    {1,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
    {1,-1},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
    {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
    {0,-1}
};


/*!
  \fn Fluxo::Fluxo(Fluxo const& fluxoCopia)
    \brief Copy Constructor.
    Creates an object receiving attributes from fluxoCopia


  */

Fluxo::Fluxo(Fluxo const& fluxoCopia){
    valorPadraoFluxo = fluxoCopia.valorPadraoFluxo;
    this->nColunas = fluxoCopia.nColunas;
    this->nLinhas = fluxoCopia.nLinhas;

    direcao = new unsigned char *[nLinhas];
    fluxo = new int *[nLinhas];
    rio =  new bool *[nLinhas];


    fluxoMinimo  = fluxoCopia.fluxoMinimo;

    //inicializando vetores
    for(int i = 0; i < nLinhas; i++){
        direcao[i] = new unsigned char [nColunas];
        for(int j=0; j<nColunas;++j)
            direcao[i][j]= fluxoCopia.direcao[i][j];


        fluxo[i] = new int [nColunas];
        rio[i] =  new bool [nColunas];


    }


    for(int i = 0; i < nLinhas; i++){
        for(int j=0; j< nColunas;j++){
            fluxo[i][j] = fluxoCopia.fluxo[i][j] ;
            rio[i][j] = fluxoCopia.rio[i][j];
        }
    }





    qtdeCelulasRio = fluxoCopia.qtdeCelulasRio;


}

/*!
  \fn Fluxo::~Fluxo()
  \brief Destructor
  */

Fluxo::~Fluxo(){


    try{

        //deletando vetores alocados dinamicamente
        for(int i = 0; i < nLinhas; i++){
            delete []this->direcao[i];
            delete []this->fluxo[i];
            delete []this->rio[i];
        }

        delete []this->direcao;
        delete []this->fluxo;
        delete []this->rio;

        //previndo que os ponteiros acessem memoria invalida
        this->direcao = NULL;
        this->fluxo = NULL;
        this->rio = NULL;
    }catch(exception e){


        QString erroMsg="Erro no destrutor da classe Fluxo";
        ofstream erro(JanelaPrincipal::urllog.toStdString().data());


        erro<<"Erro ocorrido em: ";
        erro<< QDate::currentDate().toString("dd.MM.yyyy").toStdString();
        erro<<endl;
        erro<<erroMsg.toStdString()<<endl;
        erro<<e.what()<<endl;
        erro.close();




    }


}

/*!
  \fn Fluxo::Fluxo(int nLinhas, int nColunas)
  \brief Constructor.
  Creates an object that have only the variables initialized, no drainage network is calculed yet.
  */

Fluxo::Fluxo(int nLinhas, int nColunas) {



    valorPadraoFluxo = nLinhas;
    direcao = new unsigned char *[nLinhas];
    fluxo = new int *[nLinhas];
    rio =  new bool *[nLinhas];


    //inicializando vetores
    for(int i = 0; i < nLinhas; i++){
        direcao[i] = new unsigned char [nColunas];
        for(int j=0; j<nColunas;++j)
            direcao[i][j]=0;


        fluxo[i] = new int [nColunas];
        rio[i] =  new bool [nColunas];


    }


    this->nColunas = nColunas;
    this->nLinhas = nLinhas;

    qtdeCelulasRio = 0;



}

void Fluxo::setInundacao(short int** elevacoes) {


    //setando as bordas da matriz direcao com valores padroes
    for(int i = 0; i < this->nLinhas;i++){
        //inserindo no vetor de filas os elementos da primeira e ultima coluna
        vetorDeFilasDeNiveis[elevacoes[i][0] + limiteAltidude].push(ponto(i,0));
        //int auxA = elevacoes[i][this->nColunas - 1] + limiteAltidude;
        vetorDeFilasDeNiveis[elevacoes[i][this->nColunas - 1] + limiteAltidude].push(ponto(i,this->nColunas - 1));

        direcao[i][0] = dirEsquerda;
        direcao[i][this->nColunas - 1] = dirDireita;

    }


    for(int i = 1; i < this->nColunas -1 ;i++){
        //inserindo no vetor de filas os elementos da primeira e ultima linha
        vetorDeFilasDeNiveis[elevacoes[0][i] + limiteAltidude].push(ponto(0,i));
        vetorDeFilasDeNiveis[elevacoes[this->nLinhas - 1][i] + limiteAltidude].push(ponto(this->nLinhas - 1,i));

        direcao[0][i] = dirCima;
        direcao[this->nLinhas - 1][i] = dirBaixo;

    }
    //final setando bordas


    int nivelDoMar = (-1)*limiteAltidude;

    for(;nivelDoMar<limiteAltidude;nivelDoMar++){
        //retirando os elementos da filas de elevecoes
        //assim estara retirando de forma ordenada
        while(!vetorDeFilasDeNiveis[nivelDoMar + limiteAltidude].empty()){
            ponto p = vetorDeFilasDeNiveis[nivelDoMar+limiteAltidude].front();
            vetorDeFilasDeNiveis[nivelDoMar+limiteAltidude].pop();

            //verificando se esta nas bordas
            // recordando p.first = y e p.second = x
            int x = p.second;
            int y = p.first;


            if(x != 0 && y!=0)
                //vizinho esquerda cima
                if (direcao[y-1][x-1] == 0) {
                    direcao[y-1][x-1] = dirDireitaBaixo;

                    if ( elevacoes[ y-1][ x-1 ] <= nivelDoMar )  elevacoes[ y-1][x-1 ] = nivelDoMar;

                    vetorDeFilasDeNiveis[ limiteAltidude +elevacoes[ y-1][x-1 ]].push( ponto(y-1,x-1 ) );
                }

            if(y != 0)
                //vizinho cima
                if (direcao[y-1][x] == 0) {
                    direcao[y-1][x] = dirBaixo;

                    if ( elevacoes[ y-1][ x ] <= nivelDoMar )  elevacoes[ y-1][x ] = nivelDoMar;

                    vetorDeFilasDeNiveis[ limiteAltidude +elevacoes[ y-1][x ]].push( ponto(y-1,x ) );
                }


            if(x != (this->nColunas-1) && y!=0)
                //vizinho direita cima
                if (direcao[y-1][ x+1] == 0) {
                    direcao[y-1][ x+1] = dirEsquerdaBaixo;

                    if ( elevacoes[ y-1][ x+1 ] <= nivelDoMar )  elevacoes[ y-1][ x+1 ] = nivelDoMar;

                    vetorDeFilasDeNiveis[ limiteAltidude +elevacoes[ y-1][ x+1 ]].push( ponto(y-1, x+1 ) );
                }


            if(x != (this->nColunas-1))
                //vizinho direita
                if (direcao[y][x+1] == 0) {
                    direcao[y][x+1] = dirEsquerda;

                    if ( elevacoes[y][x+1] <= nivelDoMar )  elevacoes[y][x+1] = nivelDoMar;

                    vetorDeFilasDeNiveis[ limiteAltidude +elevacoes[y][x+1]].push( ponto(y,x+1 ) );
                }

            if(x != (this->nColunas-1) && y!= (this->nLinhas-1))
                //vizinho direita baixo
                if (direcao[y+1][x+1] == 0) {
                    direcao[y+1][x+1] = dirEsquerdaCima;

                    if ( elevacoes[y+1][x+1] <= nivelDoMar )  elevacoes[y+1][x+1] = nivelDoMar;

                    vetorDeFilasDeNiveis[ limiteAltidude +elevacoes[y+1][x+1]].push( ponto(y+1,x+1 ) );
                }

            if(y!= (this->nLinhas-1))
                //vizinho baixo
                if (direcao[y+1][x] == 0) {
                    direcao[y+1][x] = dirCima;

                    if ( elevacoes[y+1][x] <= nivelDoMar )  elevacoes[y+1][x] = nivelDoMar;

                    vetorDeFilasDeNiveis[ limiteAltidude +elevacoes[y+1][x]].push( ponto(y+1,x ) );
                }

            if(x != 0 && y!= (this->nLinhas-1))
                //vizinho esquerda baixo
                if (direcao[y+1][x-1] == 0) {
                    direcao[y+1][x-1] = dirDireitaCima;

                    if ( elevacoes[y+1][x-1] <= nivelDoMar )  elevacoes[y+1][x-1] = nivelDoMar;

                    vetorDeFilasDeNiveis[ limiteAltidude +elevacoes[y+1][x-1]].push( ponto(y+1,x-1 ) );
                }

            if(x != 0)
                //vizinho esquerda
                if (direcao[y][x-1] == 0) {
                    direcao[y][x-1] = dirDireita;

                    if ( elevacoes[y][x-1] <= nivelDoMar )  elevacoes[y][x-1] = nivelDoMar;

                    vetorDeFilasDeNiveis[ limiteAltidude +elevacoes[y][x-1]].push( ponto(y,x-1 ) );
                }

        }//fim while


    }//fim for







}

void Fluxo::setFluxo(short int** elevacoes) {

    int **grauDeEntradaDeFluxo;
    grauDeEntradaDeFluxo =  new int *[nLinhas];

    for(int i=0; i<nLinhas; ++i){
        grauDeEntradaDeFluxo[i] = new int [nColunas];
        for(int j=0; j<nColunas; ++j)
            grauDeEntradaDeFluxo[i][j] = 0;
    }


    //Define quantidade de fluxo de entrada para cada ponto que recebe fluxo do ponto (i,j)
    for(int i=0;i<nLinhas;i++)
        for(int j=0;j<nColunas;j++) {
            fluxo[i][j] = 1; //Aproveita para inicializar o fluxo

            unsigned int ptDir = (unsigned int) direcao[i][j];

            if (ptDir!=0) {
                //Teste para não acessar memória invalida ou fora da borda da matriz
                if (i+direcaoDeFluxo[ptDir][0] <0  || j+direcaoDeFluxo[ptDir][1] <0 || i+direcaoDeFluxo[ptDir][0] >=nLinhas  || j+direcaoDeFluxo[ptDir][1] >=nLinhas )
                    continue;

                grauDeEntradaDeFluxo[ i+direcaoDeFluxo[ptDir][0] ][ j+direcaoDeFluxo[ptDir][1] ]++;
            }
        }



    for(int i=0;i<nLinhas;i++)
        for(int j=0;j<nColunas;j++) {

            ponto p(i,j);
            //Distribui o fluxo do ponto (i,j) ao vizinho de (i,j) que recebe seu fluxo

            while(grauDeEntradaDeFluxo[ p.first ][ p.second ]==0) {
                grauDeEntradaDeFluxo[ p.first ][ p.second ] = processado; //Marca ponto como processado
                unsigned int dirPt = (unsigned int)direcao[p.first][p.second];
                ponto vizinho( p.first+direcaoDeFluxo[dirPt][0], p.second+direcaoDeFluxo[dirPt][1] );

                //Evita acessar posição inválida
                if (vizinho.first <0  || vizinho.second <0 || vizinho.first >=nLinhas  || vizinho.second >=nColunas )
                    break;


                //Incrementa fluxo e reduz grau de entrada do vizinho
                fluxo[ vizinho.first ][ vizinho.second ]+= fluxo[p.first][p.second];
                grauDeEntradaDeFluxo[ vizinho.first ][ vizinho.second ]--;
                p = vizinho; //Repete processo para vizinho
            }
        }






    //Deleta grauDeEntradaDeFluxo
    for(int i=0;i< nLinhas;i++) delete []grauDeEntradaDeFluxo[i];
    delete grauDeEntradaDeFluxo;


}

void Fluxo::setRio(short int** elevacoes,int noData) {

    //Se o usuário não definiu fluxo minimo, sera utilizado valor padrao
    if(fluxoMinimo==0)
        fluxoMinimo=valorPadraoFluxo;

    qtdeCelulasRio = 0; //ja foi inicializada mas apenas por garantia

    //Percorre a matriz de rio, marcando como true as posições cujo fluxo é maior que o valor definido por fluxo minimo
    for(int i=0; i<nLinhas; ++i)
        for(int j=0; j<nColunas; ++j)
            if(fluxo[i][j]>=fluxoMinimo && elevacoes[i][j] != noData){
                rio[i][j]=true;
                qtdeCelulasRio++;
            }
            else rio[i][j]=false;

}

