
#include "Inundacao.h"
#include <fstream>
#include<cstdlib>
#include<math.h>
#include<QDate>
#include <janelaprincipal.h>


/*!
  \class Inundacao


     \previouspage Fluxo

     \contentspage

     \nextpage janelabarragem

     \startpage All Classes


  \brief Class to create the resorvoir, with the dam and flooded cells

  */


/*!
  \class PontoZ
  \brief Class to create point to represent a cell

  */
/*!
    \variable Inundacao::matrizEstados
    \brief a pointer to pointer representing the matrix of states of cell. If cell are dam, flooded, drainage network or nothing


  */

/*!
    \variable Inundacao::posicaoBarragem
    \brief a cell representing by a point to identify the dam position


  */
/*!
    \variable Inundacao::posicaoBarragem
    \brief a cell representing by a point to identify the the position downstream the dam position



  */

/*!
    \variable Inundacao::vetorNormalABarragem
    \brief a point to describe the final point of the dam`s normal vector. The start point is the dam position.
    with this point we can calculate the direction of the dam use simple math calcs.


  */

/*!
  \variable Inundacao::nLinhas
  \brief the number of lines of MDE


*/
/*!
  \variable Inundacao::nColunas
  \brief the number of columns of MDE


*/


/*!
    \variable Inundacao::tamanhoMaximoDaBarragem
    \brief the maximum value of dam extent. Its not used in the algorithm yet


  */
/*!
    \variable Inundacao::volumeAgua
    \brief the value of current resorvoir`s volume.

  */

/*!
    \variable Inundacao::volumeAlvo
    \brief the value volume required by user to construct the reservoir.

  */

/*!
    \variable Inundacao::nivelAgua
    \brief the value of current high of the water generated by the flooding


  */


/*!
    \variable Inundacao::areaLaminaAgua
    \brief the value of the flooded area in the reservoir


  */
/*!
    \variable Inundacao::areaBarragemTocada
    \brief the value of the area for the dam


  */
/*!
    \variable Inundacao::comprimentoBarragemTocada
    \brief the value of the dam`s extent


  */




/*!
  \fn Inundacao::Inundacao(Inundacao const& inundacaoCopia)
    \brief Copy Constructor.
    Creates an object receiving attributes from inundacaoCopia


  */


Inundacao::Inundacao(Inundacao const& inundacaoCopia){

    this->nLinhas = inundacaoCopia.nLinhas;
    this->nColunas = inundacaoCopia.nColunas;




    //========================================================
    //===========Constroi e inicializa matrizes===============

    this->matrizEstados = new short int*[nLinhas];
    for(int i=0; i<nLinhas; ++i)
    {
        matrizEstados[i] = new short int[nColunas];
        for(int j=0; j<nColunas ; ++j)
            matrizEstados[i][j] = inundacaoCopia.matrizEstados[i][j];
    }

    this->visitado = new bool*[nLinhas];
    for(int i=0; i<nLinhas; ++i)
    {
        visitado[i] = new bool[nColunas];
        //Inicializa valores da matriz
        for(int j=0; j<nColunas; ++j)
            visitado[i][j] = inundacaoCopia.visitado[i][j];
    }
    //========================================================
    //========================================================

    //===Inicializa variáveis===
    volumeAgua = inundacaoCopia.volumeAgua;
    areaLaminaAgua = inundacaoCopia.areaLaminaAgua;
    areaBarragemTocada = inundacaoCopia.areaBarragemTocada;
    comprimentoBarragemTocada = inundacaoCopia.comprimentoBarragemTocada;
    nivelAgua = inundacaoCopia.nivelAgua;

    posicaoBarragem.x = inundacaoCopia.posicaoBarragem.x;
    posicaoBarragem.y = inundacaoCopia.posicaoBarragem.y;
    posicaoBarragem.z = inundacaoCopia.posicaoBarragem.z;

    //Define valores iniciais
    volumeAlvo = inundacaoCopia.volumeAlvo;
    tamanhoMaximoDaBarragem = inundacaoCopia.tamanhoMaximoDaBarragem;



}

/*!
  \fn Inundacao::~Inundacao()
    \brief Destructor

  */
Inundacao::~Inundacao(){


    try{
        //liberando a memoria apontada pelos ponteiros
        for(int i = 0; i < nLinhas; i++){
            delete []this->matrizEstados[i];
            delete []this->visitado[i];
        }

        delete []this->matrizEstados;
        delete []this->visitado;


        //previnindo que os ponteiros acessem memoria invalida
        this->matrizEstados = NULL;
        this->visitado = NULL;

    }catch(exception e){


        QString erroMsg="Erro no destrutor da classe Inundacao";
        ofstream erro(JanelaPrincipal::urllog.toStdString().data());


        erro<<"Erro ocorrido em: ";
        erro<< QDate::currentDate().toString("dd.MM.yyyy").toStdString();
        erro<<endl;
        erro<<erroMsg.toStdString()<<endl;
        erro<<e.what()<<endl;
        erro.close();
    }

}

/*!
  \fn Inundacao::Inundacao(int linhas, int colunas)
  \brief Constructor.
  Creates an object that have only the variables initialized, no reservoir is calculed yet.
  */

Inundacao::Inundacao(int linhas, int colunas)
{
    this->nLinhas = linhas;
    this->nColunas = colunas;



    //========================================================
    //===========Constroi e inicializa matrizes===============

    this->matrizEstados = new short int*[nLinhas];
    for(int i=0; i<nLinhas; ++i)
    {
        matrizEstados[i] = new short int[nColunas];
        for(int j=0; j<nColunas ; ++j)
            matrizEstados[i][j] = 1;
    }

    this->visitado = new bool*[nLinhas];
    for(int i=0; i<nLinhas; ++i)
    {
        visitado[i] = new bool[nColunas];
        //Inicializa valores da matriz
        for(int j=0; j<nColunas; ++j)
            visitado[i][j] = false;
    }
    //========================================================
    //========================================================

    //===Inicializa variáveis===
    volumeAgua = 0;
    areaLaminaAgua = 0;
    areaBarragemTocada = 0;
    comprimentoBarragemTocada = 0;
    nivelAgua = 0;

    posicaoBarragem.x = -1;
    posicaoBarragem.y = -1;
    posicaoBarragem.z = -1;

    //Define valores iniciais
    volumeAlvo = 30;
    tamanhoMaximoDaBarragem = 5;



}


/*!
  \fn Inundacao::permiteInundacaoEAumentaBarragem(PontoZ pontoAvaliado)
  \brief Function used to test if a point pontoAvaliado can be a flooded cell.
If this point is in the same direction of the dam, it will grow up. If not
  the algorithm test if it can be or not a flooded cell.
  */
bool Inundacao::permiteInundacaoEAumentaBarragem(PontoZ pontoAvaliado){
    //posicaoBarragem(p1) barragem fixa, posicaoAcimaBarragem(p2) vizinho mais a jusante do p1, pontoAvaliado(p3) elemento a ser testado
    //produto escalar produtoEscalar = p1p2.p1p3
    // define o angulo entre os dois vetores
    int produtoEscalar = (vetorNormalABarragem.x)*(pontoAvaliado.x -posicaoBarragem.x) + (vetorNormalABarragem.y)*(pontoAvaliado.y - posicaoBarragem.y);
    visitado[pontoAvaliado.y][pontoAvaliado.x] = true;

    //se forem perpendiculares poe barragem no p3, ou seja produtoEscalar = 0
    //e aumenta a barragem  e retorna falso
    if(produtoEscalar == 0){
        matrizEstados[pontoAvaliado.y][pontoAvaliado.x] = BARRAGEM;

        comprimentoBarragemTocada++;
        return false;
    }else


        //se produtoEscalar > 0 o angulo entre eles eh < 90
        //retorna true

        //se produto escalar < 90 retorne false

        return produtoEscalar>0?true:false;





}



/*!
  \fn Inundacao::inicializaBarragem(int x, int y, int xAcima, int yAcima, short int** elevacoes,bool **rio,unsigned char**matrizDeDirecoes, int opVetorNormal,int valorVetorNormal,int valEp)
  \brief Initialize the variable needed to create the reservoir
  */

void Inundacao::inicializaBarragem(int x, int y, int xAcima, int yAcima, short int** elevacoes,bool **rio,unsigned char**matrizDeDirecoes, int opVetorNormal,int valorVetorNormal,int valEp)
{
    posicaoBarragem.x = x;
    posicaoBarragem.y = y;
    posicaoBarragem.z = elevacoes[y][x];



    defineVetorNormalABarragem(opVetorNormal,valorVetorNormal,elevacoes,rio,matrizDeDirecoes,valEp);

    posicaoAcimaBarragem.x = xAcima;
    posicaoAcimaBarragem.y = yAcima;
    posicaoAcimaBarragem.z = elevacoes[yAcima][xAcima];

    for(int i=0;i<nLinhas;i++)
        for(int j=0;j<nColunas;j++)
            visitado[i][j] = false;

    filaProximosPontos = priority_queue< PontoZ >();
    filaProximosPontos.push( posicaoAcimaBarragem );
    visitado[posicaoAcimaBarragem.y][posicaoAcimaBarragem.x] = true;

    volumeAgua = 0;
    areaLaminaAgua = 0;
    areaBarragemTocada = 0;
    comprimentoBarragemTocada = 0;
    nivelAgua = posicaoAcimaBarragem.z-1;

}


/*!
  \fn Inundacao::marcaMontante(int xi, int yi, short int** matrizDeEstados, unsigned char** matrizDeDirecoes, short int** elevacoes,bool **rio,int opVetorNormal,int valorVetorNormal,int valEp)
  \brief Initialize the process of construct the dam
  */
void Inundacao::marcaMontante(int xi, int yi, short int** matrizDeEstados, unsigned char** matrizDeDirecoes, short int** elevacoes,bool **rio,int opVetorNormal,int valorVetorNormal,int valEp)
{
    int x = proximoX(yi,xi); //Pega coordenada X do ponto para o qual (xi,yi) flui
    int y = proximoY(yi,xi); //Pega coordenada Y do ponto para o qual (xi,yi) flui




    inicializaBarragem(x,y,xi,yi,elevacoes,rio,matrizDeDirecoes,opVetorNormal, valorVetorNormal,valEp);

    QQueue<PontoZ> filaDePontos;
    filaDePontos.push_back(PontoZ(y,x,0));

    //===Inicializa matriz de estados===
    for(int i=0;i<nLinhas;i++)
        for(int j=0;j<nColunas;j++)
            matrizDeEstados[i][j] = 1;


    //Marca pontos vizinhos do ponto (x,y)
    while(!filaDePontos.empty()) {
        PontoZ p = filaDePontos.front(); filaDePontos.pop_front();

        int i,j;

        i = p.y-1;
        j = p.x-1;
        if (i>=0 && j>=0 && i<nColunas && j<nLinhas && proximoY(i,j) == p.y && proximoX(i,j)==p.x) { //i,j fluem para p?
            matrizDeEstados[j][i] = AFLUENTE;
            filaDePontos.push_back(PontoZ(i,j,0));
        }
        i = p.y-1;
        j = p.x;
        if (i>=0 && j>=0 && i<nColunas && j<nLinhas && proximoY(i,j) == p.y && proximoX(i,j)==p.x) { //i,j fluem para p?
            matrizDeEstados[j][i] = AFLUENTE;
            filaDePontos.push_back(PontoZ(i,j,0));
        }
        i = p.y-1;
        j = p.x+1;
        if (i>=0 && j>=0 && i<nColunas && j<nLinhas && proximoY(i,j) == p.y && proximoX(i,j)==p.x) { //i,j fluem para p?
            matrizDeEstados[j][i] = AFLUENTE;
            filaDePontos.push_back(PontoZ(i,j,0));
        }

        i = p.y;
        j = p.x-1;
        if (i>=0 && j>=0 && i<nColunas && j<nLinhas && proximoY(i,j) == p.y && proximoX(i,j)==p.x) { //i,j fluem para p?
            matrizDeEstados[j][i] = AFLUENTE;
            filaDePontos.push_back(PontoZ(i,j,0));
        }
        i = p.y;
        j = p.x+1;
        if (i>=0 && j>=0 && i<nColunas && j<nLinhas && proximoY(i,j) == p.y && proximoX(i,j)==p.x) { //i,j fluem para p?
            matrizDeEstados[j][i] = AFLUENTE;
            filaDePontos.push_back(PontoZ(i,j,0));
        }


        i = p.y+1;
        j = p.x-1;
        if (i>=0 && j>=0 && i<nColunas && j<nLinhas && proximoY(i,j) == p.y && proximoX(i,j)==p.x) { //i,j fluem para p?
            matrizDeEstados[j][i] = AFLUENTE;
            filaDePontos.push_back(PontoZ(i,j,0));
        }
        i = p.y+1;
        j = p.x;
        if (i>=0 && j>=0 && i<nColunas && j<nLinhas && proximoY(i,j) == p.y && proximoX(i,j)==p.x) { //i,j fluem para p?
            matrizDeEstados[j][i] = AFLUENTE;
            filaDePontos.push_back(PontoZ(i,j,0));
        }
        i = p.y+1;
        j = p.x+1;
        if (i>=0 && j>=0 && i<nColunas && j<nLinhas && proximoY(i,j) == p.y && proximoX(i,j)==p.x) { //i,j fluem para p?
            matrizDeEstados[j][i] = AFLUENTE;
            filaDePontos.push_back(PontoZ(i,j,0));
        }
    }


    marcaBarragem(matrizDeEstados);



}


/*!
  \fn Inundacao::marcaBarragem(short int **matrizDeEstados)
  \brief Mark the points in MDE that could be a dam cell
  */
void Inundacao::marcaBarragem(short int **matrizDeEstados){




    //marcando a baragem apartir do ponto de insercao da mesma

    //identificando a direcao perpendicular


    int ebx,eby,ebxIni,ebyIni;
    int dx,dy;

    int i = posicaoBarragem.y;
    int  j = posicaoBarragem.x;

    matrizDeEstados[i][j] = BARRAGEM;
    visitado[i][j] = true;
    comprimentoBarragemTocada = 1;




    int ax = vetorNormalABarragem.x;
    int ay = vetorNormalABarragem.y;



    if(vetorNormalABarragem.x*vetorNormalABarragem.y == 0){

        if(vetorNormalABarragem.x == 0){

            dy = 0;
            dx = 1;

            ebx = j;
            eby = i+1;



        }else{
            dy = 1;
            dx = 0;

            ebx = j+1;
            eby = i;


        }





    }else{


        if(vetorNormalABarragem.x*vetorNormalABarragem.y>0){

            dx = 1;
            dy = -1;


            ebx = j+1;
            eby = i;




        }else{

            dx = 1;
            dy = 1;

            ebx = j+1;
            eby = i;


        }




    }

/*
    if(vetorNormalABarragem.x == 0){
        dy = 0;
        dx = 1;

        ebx = j;
        eby = i+1;

    }else{

        dx = (-1)*vetorNormalABarragem.x/abs(vetorNormalABarragem.x);
        ebx = j;



    }

    if(vetorNormalABarragem.y == 0){
        dy = 1;
        dx = 0;

        ebx = j+1;
        eby = i;

    }else{

        dy = vetorNormalABarragem.y/abs(vetorNormalABarragem.y);

        eby = i -dy;


    }

*/
    ebxIni = ebx;
    ebyIni = eby;

    if(!(eby<0 || ebx<0 || eby>=nLinhas || ebx>=nColunas)){
        matrizDeEstados[eby][ebx] = ACIMA_BARRAGEM;
        visitado[eby][ebx] = true;

    }






    //andar pelo terreno para dx,dy
    while(true){

        i = i+dy;
        j = j+dx;

        ebx = ebx + dx;
        eby = eby +dy;

        //inserindo barragem imaginaria
        if(!(eby<0 || ebx<0 || eby>=nLinhas || ebx>=nColunas)){
            matrizDeEstados[eby][ebx] = ACIMA_BARRAGEM;
            visitado[eby][ebx] = true;


        }


        //excede os limites da matriz
        if(i<0 || j<0 || i>=nLinhas || j>=nColunas ) break;

        matrizDeEstados[i][j] = BARRAGEM;
        visitado[i][j] = true;
        comprimentoBarragemTocada++;


    }


    i = posicaoBarragem.y;
    j = posicaoBarragem.x;



    ebx = ebxIni;
    eby = ebyIni;

    if(!(eby<0 || ebx<0 || eby>=nLinhas || ebx>=nColunas)){
        matrizDeEstados[eby][ebx] = ACIMA_BARRAGEM;
        visitado[eby][ebx] = true;

    }

    //andar pelo terreno para -dx -dy

    while(true){

        i = i-dy;
        j = j-dx;


        ebx = ebx - dx;
        eby = eby -dy;

        //inserindo marragem imaginaria
        if(!(eby<0 || ebx<0 || eby>=nLinhas || ebx>=nColunas)){
            matrizDeEstados[eby][ebx] = ACIMA_BARRAGEM;
            visitado[eby][ebx] = true;

        }
        //excede os limites da matriz
        if(i<0 || j<0 || i>=nLinhas || j>=nColunas) break;

        matrizDeEstados[i][j] = BARRAGEM;
        visitado[i][j] = true;
        comprimentoBarragemTocada++;


    }










}



/*!
  \fn Inundacao::sobeNivelDeAgua(short int** matrizDeEstados, short int** elevacoes)
  \brief Rise the water`s level flooding cells generated new values for variable
  */
void Inundacao::sobeNivelDeAgua(short int** matrizDeEstados, short int** elevacoes) {
    if (filaProximosPontos.empty()) {
        return;
    }
    PontoZ p = filaProximosPontos.top();
    int nivelAguaAntes = nivelAgua;
    nivelAgua = p.z;
    volumeAgua += (nivelAgua-nivelAguaAntes)*areaLaminaAgua;
    areaBarragemTocada += (nivelAgua-nivelAguaAntes)*comprimentoBarragemTocada;

    if (matrizDeEstados[p.y][p.x]==3) { //Erro ao colocar constante do define ACIMA_BARRAGEM
        comprimentoBarragemTocada++;
    }


    while(filaProximosPontos.top().z <= nivelAgua) {
        p = filaProximosPontos.top(); filaProximosPontos.pop();

        areaLaminaAgua++;

        //inunda o cara e coloca os seus vizinhos na fila para serem inundados


        PontoZ auxParaAvaliar;
        {
            int i = -1+p.y;
            int j = p.x;
            auxParaAvaliar.x = j;
            auxParaAvaliar.y = i;
            if (!(i<0 || i>=nLinhas || j<0 || j>=nColunas || visitado[i][j]) /*&& ( permiteInundacaoEAumentaBarragem(auxParaAvaliar))*/) {
                filaProximosPontos.push( PontoZ(i,j,elevacoes[i][j]) );
                visitado[i][j] = true;
            }
        }

        {
            int i = 1+p.y;
            int j = p.x;
            auxParaAvaliar.x = j;
            auxParaAvaliar.y = i;
            if ((!(i<0 || i>=nLinhas || j<0 || j>=nColunas || visitado[i][j])) /*&& ( permiteInundacaoEAumentaBarragem(auxParaAvaliar))*/) {
                filaProximosPontos.push( PontoZ(i,j,elevacoes[i][j]) );
                visitado[i][j] = true;
            }
        }

        {
            int i = p.y;
            int j = -1+p.x;
            auxParaAvaliar.x = j;
            auxParaAvaliar.y = i;
            if ((!(i<0 || i>=nLinhas || j<0 || j>=nColunas || visitado[i][j])) /*&& ( permiteInundacaoEAumentaBarragem(auxParaAvaliar))*/) {
                filaProximosPontos.push( PontoZ(i,j,elevacoes[i][j]) );
                visitado[i][j] = true;
            }
        }

        {
            int i = p.y;
            int j = 1+p.x;
            auxParaAvaliar.x = j;
            auxParaAvaliar.y = i;
            if (!(i<0 || i>=nLinhas || j<0 || j>=nColunas || visitado[i][j]) /*&& ( permiteInundacaoEAumentaBarragem(auxParaAvaliar))*/)  {
                filaProximosPontos.push( PontoZ(i,j,elevacoes[i][j]) );
                visitado[i][j] = true;
            }
        }


        if (matrizDeEstados[p.y][p.x]==3){ //Erro ao usar define ACIMA_BARRAGEM
            matrizDeEstados[p.y][p.x] = AGUA_BORDA_BARRAGEM;
        }
        else{
            matrizDeEstados[p.y][p.x] = AGUA;




        }
    }





}



/*!
  \fn Inundacao::defineVetorNormalABarragem(int op,int val,short int **elevacoes,bool **rio,unsigned char**matrizDeDirecoes,int valEp)
  \brief Definy what function to call to calculate the dam`s normal vector
  */
//define qual funcao chamar para calculo do vetor normal
void Inundacao::defineVetorNormalABarragem(int op,int val,short int **elevacoes,bool **rio,unsigned char**matrizDeDirecoes,int valEp){


    //se for o algoritmo dos vizinhos
    if(op == 10){

        vetorNormalPorMediaSimples(val,elevacoes,rio,matrizDeDirecoes);
    }

    if(op == 20)
    {
        vetorNormalPorDouglasPeucker(val,valEp,elevacoes,rio,matrizDeDirecoes);
    }

    if(op == 30){

        vetorNormalPorMediaPonderada(val,elevacoes,rio,matrizDeDirecoes);
    }


    //direcoes manuais,
    //lembrado que é setado o par (x,y) para o vetor normal
    // e que o crescimento da barragem é +x pra direita e +y para baixo
    //direcao manual com dir =0

    if(op == 101){
        vetorNormalABarragem.x = 0;
        vetorNormalABarragem.y = 1;

    }

    //direcao manual com dir =45
    if(op == 102){
        vetorNormalABarragem.x = 1;
        vetorNormalABarragem.y = 1;

    }

    //direcao manual com dir =90
    if(op == 103){
        vetorNormalABarragem.x = 1;
        vetorNormalABarragem.y = 0;

    }

    //direcao manual com dir =135
    if(op == 104){
        vetorNormalABarragem.x = -1;
        vetorNormalABarragem.y = 1;

    }

}



/*!
  \fn Inundacao::criaListaParaDouglasPeucker(int numElementos,QList<PontoZ> &listaASerSimplificada,short int **elevacoes,bool**rio,unsigned char**matrizDeDirecoes)
  \brief Definy what points in drainage network will be in the Douglas-Peucker algorithm
  */

//usa-se o algoritmo de douglas peucker para identificar o vetor
//normal a barragem

void Inundacao::criaListaParaDouglasPeucker(int numElementos,QList<PontoZ> &listaASerSimplificada,short int **elevacoes,bool**rio,unsigned char**matrizDeDirecoes){


    listaASerSimplificada.insert(0,posicaoBarragem);

    int j = posicaoBarragem.x;
    int i = posicaoBarragem.y;

    for(int nElem = 1;nElem<numElementos;nElem++){


        //acha os oito vizinhos a montante que esta contido na rede de drenagem


        //i-1,j-1
        if((i-1)>0 && (j-1)>0 && rio[i-1][j-1]  && elevacoes[i][j]<=elevacoes[i-1][j-1]  && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i -1)) ){
            i = i-1;
            j = j-1;

            PontoZ aux(i,j,elevacoes[i][j]);
            listaASerSimplificada.insert(nElem,aux);
        }else

            //i-1,j
            if((i-1)>0  && rio[i-1][j] && elevacoes[i][j]<=elevacoes[i-1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i -1))){
                i = i-1;
                j = j;
                PontoZ aux(i,j,elevacoes[i][j]);
                listaASerSimplificada.insert(nElem,aux);
            }else

                //i-1,j+1
                if((i-1)>0 && (j+1)<nColunas && rio[i-1][j+1]  && elevacoes[i][j]<=elevacoes[i-1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i -1))){
                    i = i-1;
                    j = j+1;
                    PontoZ aux(i,j,elevacoes[i][j]);
                    listaASerSimplificada.insert(nElem,aux);
                }else

                    //i,j-1
                    if( (j-1)>0 && rio[i][j-1]  && elevacoes[i][j]<=elevacoes[i][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i ))){
                        i = i;
                        j = j-1;
                        PontoZ aux(i,j,elevacoes[i][j]);
                        listaASerSimplificada.insert(nElem,aux);
                    }else

                        //i,j+1
                        if((j+1)<nColunas && rio[i][j+1]  && elevacoes[i][j]<=elevacoes[i][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i ))){
                            i = i;
                            j = j+1;
                            PontoZ aux(i,j,elevacoes[i][j]);
                            listaASerSimplificada.insert(nElem,aux);
                        }else

                            //i+1,j-1
                            if((i+1)<nLinhas && (j-1)>0 && rio[i+1][j-1]  && elevacoes[i][j]<=elevacoes[i+1][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i +1))){
                                i = i+1;
                                j = j-1;
                                PontoZ aux(i,j,elevacoes[i][j]);
                                listaASerSimplificada.insert(nElem,aux);
                            }else

                                //i+1,j
                                if((i+1)<nLinhas  && rio[i+1][j]  && elevacoes[i][j]<=elevacoes[i+1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i +1))){
                                    i = i+1;
                                    j = j;
                                    PontoZ aux(i,j,elevacoes[i][j]);
                                    listaASerSimplificada.insert(nElem,aux);
                                }else

                                    //i+1,j+1
                                    if((i+1)<nLinhas && (j+1)<nColunas && rio[i+1][j+1]  && elevacoes[i][j]<=elevacoes[i+1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i +1))){
                                        i = i+1;
                                        j = j+1;
                                        PontoZ aux(i,j,elevacoes[i][j]);
                                        listaASerSimplificada.insert(nElem,aux);
                                    }





    }





}

//pseudo codigo do algoritmo de douglas peucker
//retirado do wikiepedia

// function DouglasPeucker(PointList[], epsilon)
//  //Find the point with the maximum distance
//  dmax = 0
//  index = 0
//  for i = 2 to (length(PointList) - 1)
//   d = PerpendicularDistance(PointList[i], Line(PointList[1], PointList[end]))
//   if d > dmax
//    index = i
//    dmax = d
//   end
//  end

//  //If max distance is greater than epsilon, recursively simplify
//  if dmax >= epsilon
//   //Recursive call
//   recResults1[] = DouglasPeucker(PointList[1...index], epsilon)
//   recResults2[] = DouglasPeucker(PointList[index...end], epsilon)

//   // Build the result list
//   ResultList[] = {recResults1[1...end-1] recResults2[1...end]}
//  else
//   ResultList[] = {PointList[1], PointList[end]}
//  end

//  //Return the result
//  return ResultList[]
// end



/*!
  \fn Inundacao::algoritmoDouglasPeucker(QList<PontoZ> &lista,int epsilon,QList<PontoZ> &resultadoLista)
  \brief The Douglas-Peucker algorithm, used to simplify the isoline and obtain a vector to be the normal vector of the dam
  */


QList<PontoZ> Inundacao::algoritmoDouglasPeucker(QList<PontoZ> &lista,int epsilon,QList<PontoZ> &resultadoLista){
    //achar o ponto com maxima distancia

    double dMax = 0;
    int iDMax = 0;

    for(int i= 1; i<(lista.size()-1);i++){

        //definindo equacao da reta
        //usado a tecnica de determinante de matriz para achar os coeficientes
        int A,B,C;
        A = lista.at(0).y - lista.at(lista.size()-1).y ;
        B =  -lista.at(0).x + lista.at(lista.size()-1).x;
        C =  (lista.at(0).x)*(lista.at(lista.size()-1).y) - (lista.at(0).y)*(lista.at(lista.size()-1).x);

        //pontos a saber a distancia
        int xP = lista.at(i).x;
        int yP = lista.at(i).y;


        //equacao da distacia
        // d = |ax+by+c|/sqtr(a2+b2)
        double d =  abs(A*xP+B*yP+C)/sqrt(pow(A,2)+pow(B,2));



        //caso o corrente seja mais distante que o mais distante ate entao
        if(d>dMax){

            dMax = d;
            iDMax = i;
        }



    }



    //If max distance is greater than epsilon, recursively simplify
    //  if dmax >= epsilon
    //   //Recursive call
    //   recResults1[] = DouglasPeucker(PointList[1...index], epsilon)
    //   recResults2[] = DouglasPeucker(PointList[index...end], epsilon)

    //   // Build the result list
    //   ResultList[] = {recResults1[1...end-1] recResults2[1...end]}
    //  else
    //   ResultList[] = {PointList[1], PointList[end]}
    //  end

    //  //Return the result
    //  return ResultList[]
    // end


    if(dMax>=epsilon){

        //chama duas chamadas recursivas do inicio ao ponto e do ponto ao fim

        QList<PontoZ> auxLista1 = lista.mid(0,iDMax);//do inicio a idMAx
        QList<PontoZ> auxLista2 = lista.mid(iDMax,-1);//ate o fim

        QList<PontoZ> resultadoListaRecursiva1 = algoritmoDouglasPeucker(auxLista1,epsilon, resultadoLista);
        QList<PontoZ> resultadoListaRecursiva2 = algoritmoDouglasPeucker(auxLista2,epsilon, resultadoLista);

        resultadoLista.append(resultadoListaRecursiva1);
        resultadoLista.append(resultadoListaRecursiva2);


    }else{

        resultadoLista.append(lista.at(0));
        resultadoLista.append(lista.at(lista.size()-1));


    }

    return resultadoLista;




}


/*!
  \fn Inundacao::vetorNormalPorDouglasPeucker(int numElementos,int epsilon,short int **elevacoes,bool**rio,unsigned char**matrizDeDirecoes)
  \brief Function to prepare and call Douglas-Peucker algorithm
  */
void Inundacao::vetorNormalPorDouglasPeucker(int numElementos,int epsilon,short int **elevacoes,bool**rio,unsigned char**matrizDeDirecoes){

    //prepara para iniciar o algoritmo de douglas peucker
    //criando-se a lista a ser simplificada
    QList<PontoZ> listaASerSimplificada;
    criaListaParaDouglasPeucker(numElementos,listaASerSimplificada,elevacoes,rio,matrizDeDirecoes);


    //usa-se o algoritmo de douglas peucker
    QList<PontoZ> resp;
    QList<PontoZ> listaSimplificada = algoritmoDouglasPeucker(listaASerSimplificada,epsilon,resp);



    //atraves da lista define o vetor perpendicular

    vetorNormalABarragem.x = listaSimplificada.at(1).x -listaSimplificada.at(0).x;
    vetorNormalABarragem.y = listaSimplificada.at(1).y -listaSimplificada.at(0).y;

}

//algoritmo para vetor normal da barragem com vizinhos mais  praximo
// a ideia do algoritmo é achar o vetor normal a barragem
//usando-se os n vizinhos  mais a montante


/*!
  \fn Inundacao::vetorNormalPorVizinhanca(int viz,short int **elevacoes,bool**rio,unsigned char**matrizDeDirecoes)
  \brief Function to calculate the dam`s normal vector by the simple sum of vector
  */
void Inundacao::vetorNormalPorMediaSimples(int viz,short int **elevacoes,bool**rio,unsigned char**matrizDeDirecoes){

    int numElementos = viz;

    //


    int j = posicaoBarragem.x;
    int i = posicaoBarragem.y;

    //acha os oito vizinhos a montante que esta contido na rede de drenagem




    //i-1,j-1
    if((i-1)>0 && (j-1)>0 && rio[i-1][j-1]  && elevacoes[i][j]<=elevacoes[i-1][j-1]  && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i -1)) ){
        i = i-1;
        j = j-1;



    }else

        //i-1,j
        if((i-1)>0  && rio[i-1][j] && elevacoes[i][j]<=elevacoes[i-1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i -1))){
            i = i-1;
            j = j;


        }else

            //i-1,j+1
            if((i-1)>0 && (j+1)<nColunas && rio[i-1][j+1]  && elevacoes[i][j]<=elevacoes[i-1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i -1))){
                i = i-1;
                j = j+1;


            }else

                //i,j-1
                if( (j-1)>0 && rio[i][j-1]  && elevacoes[i][j]<=elevacoes[i][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i ))){
                    i = i;
                    j = j-1;


                }else

                    //i,j+1
                    if((j+1)<nColunas && rio[i][j+1]  && elevacoes[i][j]<=elevacoes[i][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i ))){
                        i = i;
                        j = j+1;


                    }else

                        //i+1,j-1
                        if((i+1)<nLinhas && (j-1)>0 && rio[i+1][j-1]  && elevacoes[i][j]<=elevacoes[i+1][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i +1))){
                            i = i+1;
                            j = j-1;


                        }else

                            //i+1,j
                            if((i+1)<nLinhas  && rio[i+1][j]  && elevacoes[i][j]<=elevacoes[i+1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i +1))){
                                i = i+1;
                                j = j;


                            }else

                                //i+1,j+1
                                if((i+1)<nLinhas && (j+1)<nColunas && rio[i+1][j+1]  && elevacoes[i][j]<=elevacoes[i+1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i +1))){
                                    i = i+1;
                                    j = j+1;


                                }


    int respI = i - posicaoBarragem.y;
    int respJ = j - posicaoBarragem.x;




    for(int nElem = 1;nElem<numElementos;nElem++){




        //        //i-1,j-1
        if((i-1)>0 && (j-1)>0 && rio[i-1][j-1]  && elevacoes[i][j]<=elevacoes[i-1][j-1]  && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i -1)) ){
            i = i-1;
            j = j-1;



        }else

            //i-1,j
            if((i-1)>0  && rio[i-1][j] && elevacoes[i][j]<=elevacoes[i-1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i -1))){
                i = i-1;
                j = j;


            }else

                //i-1,j+1
                if((i-1)>0 && (j+1)<nColunas && rio[i-1][j+1]  && elevacoes[i][j]<=elevacoes[i-1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i -1))){
                    i = i-1;
                    j = j+1;


                }else

                    //i,j-1
                    if( (j-1)>0 && rio[i][j-1]  && elevacoes[i][j]<=elevacoes[i][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i ))){
                        i = i;
                        j = j-1;


                    }else

                        //i,j+1
                        if((j+1)<nColunas && rio[i][j+1]  && elevacoes[i][j]<=elevacoes[i][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i ))){
                            i = i;
                            j = j+1;


                        }else

                            //i+1,j-1
                            if((i+1)<nLinhas && (j-1)>0 && rio[i+1][j-1]  && elevacoes[i][j]<=elevacoes[i+1][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i +1))){
                                i = i+1;
                                j = j-1;


                            }else

                                //i+1,j
                                if((i+1)<nLinhas  && rio[i+1][j]  && elevacoes[i][j]<=elevacoes[i+1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i +1))){
                                    i = i+1;
                                    j = j;


                                }else

                                    //i+1,j+1
                                    if((i+1)<nLinhas && (j+1)<nColunas && rio[i+1][j+1]  && elevacoes[i][j]<=elevacoes[i+1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i +1))){
                                        i = i+1;
                                        j = j+1;


                                    }

        //atualiza variavel da soma de vetores para criar o vetor soma

        respI = respI + i -posicaoBarragem.y;
        respJ = respJ + j - posicaoBarragem.x;

    }


    vetorNormalABarragem.x = respI/numElementos;
    vetorNormalABarragem.y = respJ/numElementos;


}



void Inundacao::vetorNormalPorMediaPonderada(int viz,short int **elevacoes,bool**rio,unsigned char**matrizDeDirecoes){

    int numElementos = viz;

    int s = 0;
    int pesoVizinho = viz;

    //


    int j = posicaoBarragem.x;
    int i = posicaoBarragem.y;

    //acha os oito vizinhos a montante que esta contido na rede de drenagem
//achando o primeiro



    //i-1,j-1
    if((i-1)>0 && (j-1)>0 && rio[i-1][j-1]  && elevacoes[i][j]<=elevacoes[i-1][j-1]  && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i -1)) ){
        i = i-1;
        j = j-1;



    }else

        //i-1,j
        if((i-1)>0  && rio[i-1][j] && elevacoes[i][j]<=elevacoes[i-1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i -1))){
            i = i-1;
            j = j;


        }else

            //i-1,j+1
            if((i-1)>0 && (j+1)<nColunas && rio[i-1][j+1]  && elevacoes[i][j]<=elevacoes[i-1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i -1))){
                i = i-1;
                j = j+1;


            }else

                //i,j-1
                if( (j-1)>0 && rio[i][j-1]  && elevacoes[i][j]<=elevacoes[i][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i ))){
                    i = i;
                    j = j-1;


                }else

                    //i,j+1
                    if((j+1)<nColunas && rio[i][j+1]  && elevacoes[i][j]<=elevacoes[i][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i ))){
                        i = i;
                        j = j+1;


                    }else

                        //i+1,j-1
                        if((i+1)<nLinhas && (j-1)>0 && rio[i+1][j-1]  && elevacoes[i][j]<=elevacoes[i+1][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i +1))){
                            i = i+1;
                            j = j-1;


                        }else

                            //i+1,j
                            if((i+1)<nLinhas  && rio[i+1][j]  && elevacoes[i][j]<=elevacoes[i+1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i +1))){
                                i = i+1;
                                j = j;


                            }else

                                //i+1,j+1
                                if((i+1)<nLinhas && (j+1)<nColunas && rio[i+1][j+1]  && elevacoes[i][j]<=elevacoes[i+1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i +1))){
                                    i = i+1;
                                    j = j+1;


                                }


    int respI = (i - posicaoBarragem.y)*pesoVizinho;
    int respJ = (j - posicaoBarragem.x)*pesoVizinho;


    s += pesoVizinho;
    pesoVizinho--;





    for(int nElem = 1;nElem<numElementos;nElem++){




        //        //i-1,j-1
        if((i-1)>0 && (j-1)>0 && rio[i-1][j-1]  && elevacoes[i][j]<=elevacoes[i-1][j-1]  && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i -1)) ){
            i = i-1;
            j = j-1;



        }else

            //i-1,j
            if((i-1)>0  && rio[i-1][j] && elevacoes[i][j]<=elevacoes[i-1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i -1))){
                i = i-1;
                j = j;


            }else

                //i-1,j+1
                if((i-1)>0 && (j+1)<nColunas && rio[i-1][j+1]  && elevacoes[i][j]<=elevacoes[i-1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i -1))){
                    i = i-1;
                    j = j+1;


                }else

                    //i,j-1
                    if( (j-1)>0 && rio[i][j-1]  && elevacoes[i][j]<=elevacoes[i][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i ))){
                        i = i;
                        j = j-1;


                    }else

                        //i,j+1
                        if((j+1)<nColunas && rio[i][j+1]  && elevacoes[i][j]<=elevacoes[i][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i ))){
                            i = i;
                            j = j+1;


                        }else

                            //i+1,j-1
                            if((i+1)<nLinhas && (j-1)>0 && rio[i+1][j-1]  && elevacoes[i][j]<=elevacoes[i+1][j-1] && (proximoX(i,j) != (j-1) || proximoY(i,j) != (i +1))){
                                i = i+1;
                                j = j-1;


                            }else

                                //i+1,j
                                if((i+1)<nLinhas  && rio[i+1][j]  && elevacoes[i][j]<=elevacoes[i+1][j] && (proximoX(i,j) != (j) || proximoY(i,j) != (i +1))){
                                    i = i+1;
                                    j = j;


                                }else

                                    //i+1,j+1
                                    if((i+1)<nLinhas && (j+1)<nColunas && rio[i+1][j+1]  && elevacoes[i][j]<=elevacoes[i+1][j+1] && (proximoX(i,j) != (j+1) || proximoY(i,j) != (i +1))){
                                        i = i+1;
                                        j = j+1;


                                    }

        //atualiza variavel da soma de vetores para criar o vetor soma

        respI = respI + (i -posicaoBarragem.y)*pesoVizinho;
        respJ = respJ + (j - posicaoBarragem.x)*pesoVizinho;


        s += pesoVizinho;
        pesoVizinho--;

    }


    vetorNormalABarragem.x = respI/s;
    vetorNormalABarragem.y = respJ/s;


}


/*!
  \fn Inundacao::inunda(int posX, int posY, unsigned char** matrizDeDirecoes, short int** elevacoes,bool **rio,int opVetorNormal, int valorVetorNormal,int valEp)
  \brief Function that invoque the sequence of functions to create the reservoir
  */
//Invoca sequencia de funcções para realizar inundação
void Inundacao::inunda(int posX, int posY, unsigned char** matrizDeDirecoes, short int** elevacoes,bool **rio,int opVetorNormal, int valorVetorNormal,int valEp){

    //int x = proximoX(posY,posX);
    // int y = proximoY(posY,posX);


    try{
        marcaMontante(posX,posY,matrizEstados, matrizDeDirecoes, elevacoes,rio, opVetorNormal,valorVetorNormal,valEp);
    }catch(exception e){
        QString erroMsg="Erro no metodo marcaMontante da classe Inundacao";
        ofstream erro(JanelaPrincipal::urllog.toStdString().data());


        erro<<"Erro ocorrido em: ";
        erro<< QDate::currentDate().toString("dd.MM.yyyy").toStdString();
        erro<<endl;
        erro<<erroMsg.toStdString()<<endl;
        erro<<e.what()<<endl;
        erro.close();


    }

    while(volumeAgua<volumeAlvo) {
        try{
        sobeNivelDeAgua(matrizEstados, elevacoes);
        }catch(exception e){
            QString erroMsg="Erro no metodo sobeNivelAgua da classe Inundacao";
            ofstream erro(JanelaPrincipal::urllog.toStdString().data());


            erro<<"Erro ocorrido em: ";
            erro<< QDate::currentDate().toString("dd.MM.yyyy").toStdString();
            erro<<endl;
            erro<<erroMsg.toStdString()<<endl;
            erro<<e.what()<<endl;
            erro.close();

        }
    }


    try{
    acertaTamanhoBarragem(matrizEstados);
    }catch(exception e){
        QString erroMsg="Erro no metodo acertaTamanhoBarragem na classe Inundacao";
        ofstream erro(JanelaPrincipal::urllog.toStdString().data());


        erro<<"Erro ocorrido em: ";
        erro<< QDate::currentDate().toString("dd.MM.yyyy").toStdString();
        erro<<endl;
        erro<<erroMsg.toStdString()<<endl;
        erro<<e.what()<<endl;
        erro.close();

    }
}


/*!
  \fn Inundacao::acertaTamanhoBarragem(short int **matrizDeEstados)
  \brief Definy the real cells that are dam`s cell. Eliminate cells that arent near a flooded cell.
  */
void Inundacao::acertaTamanhoBarragem(short int **matrizDeEstados){



    int i = posicaoBarragem.y;
    int  j = posicaoBarragem.x;

    int dx,dy;

    if(vetorNormalABarragem.x*vetorNormalABarragem.y == 0){

        if(vetorNormalABarragem.x == 0){

            dy = 0;
            dx = 1;





        }else{
            dy = 1;
            dx = 0;




        }





    }else{


        if(vetorNormalABarragem.x*vetorNormalABarragem.y>0){

            dx = 1;
            dy = -1;






        }else{

            dx = 1;
            dy = 1;




        }




    }



    //achar o j,i que nao contem mais vizinhos barragem com agua em volta
    //na direcao dx dy

    while(true){



        //verificar os oito vizinhos

        //        //i-1,j-1
        if(((i-1)>0 && (j-1)>0) && (matrizDeEstados[i-1][j-1] == 5 ) ){
            i = i+dy;
            j = j+dx;



        }else

            //i-1,j
            if((i-1)>0 && (matrizDeEstados[i-1][j] == 5 )){
                i = i+dy;
                j = j+dx;


            }else

                //i-1,j+1
                if((i-1)>0 && (j+1)<nColunas && (matrizDeEstados[i-1][j+1] == 5 )){
                    i = i+dy;
                    j = j+dx;


                }else

                    //i,j-1
                    if( (j-1)>0   && (matrizDeEstados[i][j-1] == 5 )){
                        i =i+dy;
                        j = j+dx;


                    }else

                        //i,j+1
                        if((j+1)<nColunas && (matrizDeEstados[i][j+1] == 5 )){
                            i = i+dy;
                            j = j+dx;


                        }else

                            //i+1,j-1
                            if((i+1)<nLinhas && (j-1)>0  && (matrizDeEstados[i+1][j-1] == 5 )){
                                i = i+dy;
                                j = j+dx;


                            }else

                                //i+1,j
                                if((i+1)<nLinhas  && (matrizDeEstados[i+1][j] == 5 ) ){
                                    i = i+dy;
                                    j = j+dx;


                                }else

                                    //i+1,j+1
                                    if((i+1)<nLinhas && (j+1)<nColunas && (matrizDeEstados[i+1][j+1] == 5 )){
                                        i = i+dy;
                                        j = j+dx;


                                    }else{
                                        break;
                                    }



        if(i < 0 || j<0 || i>=nLinhas || j>=nColunas){

            break;

        }






    }




    //eliminando os pontos

    //eliminar para +dx e +dy
    while(true){


        if(i<0 || j<0 || i>=nLinhas || j>= nColunas) break;

        matrizDeEstados[i][j] = 1;
        comprimentoBarragemTocada--;

        i = i+dy;
        j = j+dx;
    }



    //definindo o tanto corta na direcao -dx -dy da barragem...
    i = posicaoBarragem.y;
    j = posicaoBarragem.x;


    while(true){



        //verificar os oito vizinhos

        //        //i-1,j-1
        if(((i-1)>0 && (j-1)>0) && (matrizDeEstados[i-1][j-1] == 5 ) ){
            i = i-dy;
            j = j-dx;



        }else

            //i-1,j
            if((i-1)>0 && (matrizDeEstados[i-1][j] == 5 )){
                i = i-dy;
                j = j-dx;


            }else

                //i-1,j+1
                if((i-1)>0 && (j+1)<nColunas && (matrizDeEstados[i-1][j+1] == 5 )){
                    i = i-dy;
                    j = j-dx;


                }else

                    //i,j-1
                    if( (j-1)>0   && (matrizDeEstados[i][j-1] == 5 )){
                        i =i-dy;
                        j = j-dx;


                    }else

                        //i,j+1
                        if((j+1)<nColunas && (matrizDeEstados[i][j+1] == 5 )){
                            i = i-dy;
                            j = j-dx;


                        }else

                            //i+1,j-1
                            if((i+1)<nLinhas && (j-1)>0  && (matrizDeEstados[i+1][j-1] == 5 )){
                                i = i-dy;
                                j = j-dx;


                            }else

                                //i+1,j
                                if((i+1)<nLinhas  && (matrizDeEstados[i+1][j] == 5 ) ){
                                    i = i-dy;
                                    j = j-dx;


                                }else

                                    //i+1,j+1
                                    if((i+1)<nLinhas && (j+1)<nColunas && (matrizDeEstados[i+1][j+1] == 5 )){
                                        i = i-dy;
                                        j = j-dx;


                                    }else{
                                        break;
                                    }




        if(i < 0 || j<0 || i>=nLinhas || j>=nColunas)
            break;




    }




    //cortando na direcao -dx -dy
    while(true){


        if(i<0 || j<0 || i>=nLinhas || j>= nColunas) break;
        matrizDeEstados[i][j] = 1;
        areaBarragemTocada--;
        comprimentoBarragemTocada--;



        i = i-dy;
        j = j-dx;
    }






}

/*!
  \fn Inundacao::getPosicaoBarragem()
  \brief Returns the dam position.
  */
PontoZ Inundacao::getPosicaoBarragem(){
    return posicaoBarragem;
}
